# Возможные вопросы после защиты дипломного проекта и ответы на них

## 1. Вопросы о технической реализации

### В: Каким образом реализована проверка совместимости компонентов? Расскажите подробнее об алгоритме.

**О:** Проверка совместимости компонентов реализована с использованием многоуровневой системы правил, хранящихся в базе данных:

1. Система работает по принципу попарного сравнения компонентов. Для каждой пары компонентов (например, процессор и материнская плата) из базы данных загружаются правила совместимости.

2. Для каждого правила определены характеристики, которые должны быть проверены, и тип сравнения (равенство, больше-меньше, содержание в списке и т.д.).

3. Алгоритм проверяет совместимость по формуле: процент совместимости = (общее количество возможных пар - количество несовместимых пар) / общее количество возможных пар × 100%.

4. Реализованы специализированные проверки для часто встречающихся комбинаций, например:

   - Проверка совместимости сокета процессора с материнской платой
   - Проверка поддержки накопителями интерфейсов на материнской плате
   - Проверка достаточности мощности блока питания
   - Проверка соответствия размеров корпуса и других компонентов

5. Результаты проверки кэшируются для повышения производительности, с установленным временем жизни кэша.

### В: Как обеспечивается кроссбраузерность и адаптивность интерфейса?

**О:** Кроссбраузерность и адаптивность интерфейса обеспечиваются следующими способами:

1. Использование Tailwind CSS с его системой адаптивных классов (sm:, md:, lg:, xl:), что позволяет гибко настраивать отображение элементов для разных размеров экрана.

2. Компонентный подход с выделением специальных мобильных представлений для сложных элементов интерфейса (например, MobileView.tsx для категорий в конфигураторе).

3. Применение Next.js с его оптимизацией изображений через компонент Image, который автоматически генерирует различные размеры изображений для разных устройств.

4. Тестирование на различных устройствах и в разных браузерах с использованием инструментов разработчика браузеров.

5. Использование современных CSS-свойств с автопрефиксером, который добавляет необходимые префиксы для обеспечения совместимости со старыми версиями браузеров.

### В: Как организовано хранение состояния пользовательского интерфейса (корзина, избранное, конфигурации)?

**О:** Состояние пользовательского интерфейса хранится многоуровнево:

1. Используется контекстный подход React (React Context API) – созданы контексты CartContext, FavoritesContext, ConfiguratorContext, которые обеспечивают доступ к состоянию из любого компонента приложения.

2. Данные сохраняются в куках для сохранности между сессиями с использованием собственных утилит (setStandardCookie, getStandardCookie) с настроенным временем жизни.

3. Для обратной совместимости поддерживается также localStorage, с автоматической миграцией данных из localStorage в куки.

4. Для авторизованных пользователей данные синхронизируются с сервером через API, что позволяет иметь доступ к корзине и избранному с разных устройств.

5. Реализована система управления состоянием избранного и корзины с функциями добавления, удаления и обновления элементов, а также с расчётом итоговой стоимости.

## 2. Вопросы о базе данных

### В: Как построена структура базы данных для хранения информации о компьютерных комплектующих и их характеристиках?

**О:** Структура базы данных организована следующим образом:

1. Основа – таблица products, содержащая общую информацию о товарах (название, цена, описание, изображения).

2. Категории товаров хранятся в таблице categories с поддержкой иерархической структуры через поле parent_id, что позволяет создавать вложенные категории и подкатегории.

3. Характеристики товаров реализованы через связанные таблицы:

   - characteristics_types – справочник типов характеристик (частота, объем памяти, тип разъема)
   - product_characteristics – конкретные значения характеристик для каждого товара
   - category_filter_characteristics – настройки отображения характеристик в фильтрах для каждой категории

4. Правила совместимости реализованы через набор таблиц:

   - compatibility_rules – общие правила совместимости
   - compatibility_rule_categories – привязка правил к парам категорий товаров
   - compatibility_rule_characteristics – детализация правил на уровне характеристик
   - compatibility_values – конкретные значения для сравнения

5. Для хранения пользовательских сборок используется таблица pc_builds с полем JSON для хранения конфигурации компонентов.

### В: Каким образом обеспечивается эффективность запросов к базе данных при работе с большим объемом товаров?

**О:** Эффективность запросов обеспечивается следующими способами:

1. Созданы индексы для ключевых полей таблиц, по которым чаще всего выполняется поиск (id, slug, категории).

2. Используется кэширование результатов проверки совместимости с установленным TTL (Time To Live), что позволяет не выполнять повторно сложные запросы для одинаковых комбинаций компонентов.

3. Применяются SQL-функции для перенесения сложной логики на уровень БД, например, функция get_detailed_compatibility для проверки совместимости.

4. Реализовано постраничное отображение результатов с помощью параметров LIMIT и OFFSET, что позволяет ограничить объем данных, передаваемых с сервера.

5. Оптимизированы запросы с использованием объединений (JOIN) для минимизации количества обращений к базе данных.

6. Применяется ленивая загрузка данных (lazy loading) для характеристик товаров и изображений, загружая их только при необходимости.

## 3. Вопросы о безопасности и оптимизации

### В: Какие меры безопасности реализованы в проекте для защиты пользовательских данных?

**О:** В проекте реализованы следующие меры безопасности:

1. Защита от XSS-атак с помощью автоматического экранирования вводимых пользователем данных средствами React и Next.js.

2. Использование JWT-токенов для аутентификации с проверкой их валидности при каждом запросе к API.

3. Хеширование паролей пользователей с использованием bcrypt, что предотвращает возможность получения паролей даже в случае утечки базы данных.

4. Защита от SQL-инъекций через использование ORM Drizzle с параметризованными запросами.

5. Валидация всех входных данных как на клиенте, так и на сервере с использованием библиотеки Zod.

6. Разграничение прав доступа на основе ролей пользователей (клиент, менеджер, администратор).

7. Шифрование персональных данных и информации о платежах при передаче.

### В: Какие методы оптимизации производительности веб-приложения были использованы?

**О:** Для оптимизации производительности применены следующие методы:

1. Серверный рендеринг (SSR) через Next.js для обеспечения быстрой начальной загрузки страниц.

2. Разделение кода (code splitting) с автоматической загрузкой только необходимых JavaScript-файлов для каждой страницы.

3. Оптимизация изображений через компонент Image из Next.js с автоматической генерацией разных размеров для разных устройств.

4. Кэширование данных на стороне клиента с использованием библиотеки SWR для эффективной ревалидации.

5. Использование PurgeCSS в связке с Tailwind CSS для удаления неиспользуемых стилей из финального сборочного файла.

6. Ленивая загрузка компонентов, которые не требуются для первоначального отображения страницы.

7. Инкрементальная статическая регенерация (ISR) для страниц с редко изменяющимся контентом.

8. Оптимизация шрифтов с использованием font-display: swap для предотвращения блокировки рендеринга.

## 4. Вопросы о бизнес-процессах и функциональности

### В: Как организован процесс оформления заказа, и какие этапы он включает?

**О:** Процесс оформления заказа организован следующим образом:

1. Пользователь добавляет товары в корзину (готовые сборки или индивидуальные конфигурации).

2. На странице корзины отображаются все выбранные товары с возможностью изменения количества или удаления.

3. При переходе к оформлению заказа пользователь заполняет форму с контактной информацией (для неавторизованных пользователей) или данные подгружаются из профиля.

4. Выбор способа доставки с расчетом стоимости доставки в зависимости от адреса и общего веса заказа.

5. Выбор способа оплаты (банковская карта, QR-код, оплата при получении).

6. Проверка введённых данных и подтверждение заказа.

7. Обработка платежа через платёжный шлюз (для онлайн-платежей).

8. Создание заказа в базе данных со статусом "Новый" и отправка уведомления на email пользователя.

9. Перенаправление пользователя на страницу подтверждения с информацией о номере заказа и ожидаемой дате доставки.

### В: Какие функции доступны администраторам и менеджерам системы?

**О:** Администраторы и менеджеры имеют следующие возможности:

**Администраторы:**

1. Управление каталогом товаров (добавление, удаление, редактирование).
2. Настройка категорий и их иерархической структуры.
3. Управление правилами совместимости компонентов.
4. Управление учетными записями пользователей.
5. Доступ к системным настройкам и аналитике.
6. Управление контентом сайта (новости, акции, SEO-параметры).
7. Просмотр и обработка заказов.

**Менеджеры:**

1. Просмотр и обработка новых заказов.
2. Изменение статусов заказов (принят, в обработке, отправлен, доставлен).
3. Добавление комментариев к заказам.
4. Просмотр данных о клиентах и истории их заказов.
5. Формирование отчетов о продажах.
6. Управление готовыми сборками в каталоге.

## 5. Вопросы о дальнейшем развитии

### В: Какие дополнительные функции планируется добавить в будущем?

**О:** В планах развития проекта следующие функции:

1. Интеграция с сервисами сравнения цен для предоставления пользователям информации о цене на аналогичные товары у конкурентов.

2. Расширенная аналитика сборок с оценкой производительности для разных задач (игры, работа с графикой, офисное использование).

3. Система рекомендаций, предлагающая оптимальные комплектующие на основе предпочтений пользователя и целевого использования ПК.

4. Интеграция с популярными бенчмарками для предоставления пользователям информации о ожидаемой производительности собранной конфигурации.

5. Расширенная система управления статусами заказов с оповещениями через SMS и push-уведомления.

6. Система лояльности с накоплением баллов и персональными скидками.

7. Возможность визуализации собранного компьютера в 3D.

### В: Как планируется масштабировать систему при увеличении количества пользователей и товаров?

**О:** Для масштабирования системы предусмотрены следующие меры:

1. Переход на контейнеризацию с использованием Docker и оркестрацию с Kubernetes для гибкого управления нагрузкой.

2. Внедрение CDN (Content Delivery Network) для географического распределения статических активов и сокращения времени загрузки.

3. Внедрение микросервисной архитектуры для независимого масштабирования отдельных компонентов системы (каталог, конфигуратор, корзина, заказы).

4. Оптимизация индексов базы данных и шардирование для повышения производительности при работе с большими объемами данных.

5. Внедрение системы кэширования Redis на всех уровнях (запросы API, результаты проверки совместимости, часто запрашиваемые данные).

6. Асинхронная обработка трудоемких операций через очереди сообщений (RabbitMQ или Apache Kafka).

7. Реализация горизонтального масштабирования серверов с балансировкой нагрузки.

## 6. Вопросы о тестировании и надежности

### В: Какие виды тестирования были проведены для обеспечения качества программного продукта?

**О:** Были проведены следующие виды тестирования:

1. Модульное (unit) тестирование ключевых компонентов системы, включая контексты корзины и избранного, API аутентификации, API продуктов и заказов.

2. Интеграционное тестирование для проверки взаимодействия между компонентами, например, между конфигуратором и системой проверки совместимости.

3. Тестирование пользовательского интерфейса с проверкой корректности отображения компонентов и их реакции на действия пользователя.

4. Функциональное тестирование по разработанным тест-кейсам для проверки работы основных функций (конфигуратор, оформление заказа).

5. Нагрузочное тестирование API для проверки производительности при одновременной работе множества пользователей.

6. Кроссбраузерное тестирование для обеспечения совместимости с разными браузерами и устройствами.

7. Тестирование безопасности для выявления потенциальных уязвимостей.

### В: Какие меры предусмотрены для обеспечения надежности системы?

**О:** Для обеспечения надежности системы предусмотрены следующие меры:

1. Регулярное резервное копирование базы данных с возможностью быстрого восстановления в случае сбоя.

2. Мониторинг системы с использованием инструментов логирования и аналитики для оперативного выявления и устранения проблем.

3. Обработка ошибок на всех уровнях приложения с предоставлением пользователю понятных сообщений и логированием для разработчиков.

4. Валидация всех входных данных для предотвращения сбоев из-за некорректных значений.

5. Реализация механизма отката транзакций в базе данных для обеспечения целостности данных.

6. Использование механизма повторных попыток для нестабильных внешних API (платежные системы, внешние поставщики данных).

7. Внедрение системы сбора и анализа ошибок для быстрого выявления проблем в продакшн-среде.

## 7. Практические вопросы о реализации

### В: Как реализована математическая модель расчета совместимости компонентов?

**О:** Математическая модель расчета совместимости реализована следующим образом:

1. Определяется общее количество возможных пар компонентов по формуле n×(n-1)/2, где n — количество компонентов в сборке.

2. Для каждой пары компонентов проводится проверка совместимости согласно правилам, хранящимся в базе данных.

3. Правила проверки включают различные типы сравнений:

   - equality: проверка точного совпадения значений (например, сокеты)
   - contains: проверка вхождения значения в другое (например, поддержка чипсетом определенного процессора)
   - greater_equal: проверка, что одно значение больше или равно другому (например, мощность блока питания)
   - less_equal: проверка максимально допустимых размеров (например, длина видеокарты)
   - divisible: проверка делимости (для каналов памяти)

4. После проверки всех пар подсчитывается количество несовместимых пар (k).

5. Итоговый процент совместимости вычисляется по формуле: ((C(n,2) - k) / C(n,2)) × 100%.

6. Результаты проверки сохраняются с детализацией по каждой несовместимой паре для предоставления пользователю конкретных рекомендаций по замене компонентов.

### В: Каким образом удалось реализовать эффективное хранение и обновление состояния сборки в процессе конфигурации?

**О:** Эффективное хранение и обновление состояния сборки реализовано с помощью:

1. Контекстной архитектуры React (ConfiguratorContext), которая обеспечивает централизованное хранилище для всех компонентов приложения.

2. Структуры данных в виде записи (Record<string, string>), где ключ — это slug категории, а значение — slug выбранного продукта, что обеспечивает быстрый доступ и обновление.

3. Двойной системы хранения данных:

   - В памяти приложения для быстрого доступа
   - В куках с установленным TTL для сохранения между сессиями

4. Механизма автоматического обновления зависимых данных:

   - При изменении выбранных продуктов автоматически обновляется объект selectedComponents
   - При изменении категорий обновляется статус завершенности конфигурации

5. Эффективной синхронизации с сервером для авторизованных пользователей, позволяющей сохранять и загружать конфигурации.

6. Механизма отложенного сохранения, который предотвращает частые обновления при быстрых последовательных изменениях конфигурации.
